<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>
<script>
  // 找出连续最⻓字符串： 'abcddddeefffrrrrrrrr' ==> {char: 'd', startIndex: 3, endIndex: 6}
  function findMaxlLongStr(s) {
    let left = 0, right = 0;
    let maxInfo = {}, maxLen = 0;
    while(right < s.length) {
      if (s[right] !== s[left]) {
        left = right;
      }
      if (right - left + 1 > maxLen) {
        maxLen = right - left + 1;
        maxInfo = { char: s[left], startIndex: left, endIndex: right }
      }
      right++;
    }
    return maxInfo;
  }
  console.log(findMaxlLongStr('abcddddeefff'), '___最长连续');
  console.log(findMaxlLongStr('abcddddeefffhhhhhhhhhhhhhh'));

  // "abcaxyubcbb", 无重复字符的最长子串长度
  function findMaxNoStr(s) {
    let maxLen = 0;
    const map = new Map();
    let left = 0, right = 0;
    while (right < s.length) {
      if (map.has(s[right]) && map.get(s[right]) >= left) {
        left = map.get(s[right]) + 1;
      }
      map.set(s[right], right);
      maxLen = Math.max(maxLen, right - left + 1);
      right++;
    }
    return maxLen;
  }
  console.log(findMaxNoStr('abcaxyubcbb'), 'findMaxNoStr');

  // "babad", 最长回文子串
  function getMax(s, l, r) {
    while (l >= 0 && r < s.length && s[l] === s[r]) {
      l--;
      r++;
    }
    return s.substring(l + 1, r);
  }

  function getMaxFStr(s) {
    let maxStr = '';
    for (let i = 0; i < s.length; i++) {
      const str1 = getMax(s, i, i);
      const str2 = getMax(s, i - 1, i);
      maxStr = maxStr.length > str1.length ? maxStr : str1;
      maxStr = maxStr.length > str2.length ? maxStr : str2;
    }
    return maxStr;
  }

  // 封装模板⽅法： template('{user.weight}kg', {user: {weight: 80, height: 180}}) ==> '80kg'
  function template(str, data) {
    return str.replace(/{(.+)}/g, (value1, value2) => {
      const keyArr = value2.split('.');
      let res = data;
      for (let key of keyArr) {
        res = res[key];
      }
      return res;
    })
  }

  // 示例用法
  var result = template('{user.weight}kg', { user: { weight: 80, height: 180 } });
  console.log(result); // 输出 '80kg'


  // 解析 url 参数
  // 输入 'https://www.baidu.com?name=zongwei&age=18'
  // 输出 { name: 'zongwei', age: '18' }
  function parseURL(path) {
    const str = path.match(/[^?]*$/g)[0];
    const strArr = str.split('&');
    const result = {};
    for (let item of strArr) {
      const [key, value] = item.split('=');
      if (key && value) {
        result[key] = decodeURIComponent(value);
      }
    }
    return result;
  }
  console.log(parseURL('https://www.baidu.com?name=zongwei&age=18'))

  // 实现数字的千位分隔符： 1234567.89 ==>'1,234,567.89'
  function numberWithCommas(x) {
    return String(x).replace(/(?<=\d)(?=(\d{3})+(?!\d))/g, '.')
  }

  console.log(numberWithCommas(1234567.89)); // 输出: "1,234,567.89"

  // promise
  class MyPromise {
    constructor(callback) {
      this.state = 'pending';
      this.value = '';
      this.successQueue = [];

      try {
        callback(this.resolve, this.reject)
      } catch (error) {
        this.reject(error);
      }
    }

    resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'success';
        this.value = value;
        for (let successFn of this.successQueue) {
          successFn();
        }
      }
    }

    reject = (value) => {
      if (this.state === 'pending') {
        this.state = 'fail';
        this.value = value;
      }
    }

    then = (onSuccess, onFail) => {
      const newPromise = new MyPromise((resolve, reject) => {
        if (this.state === 'pending') {
          this.successQueue.push(() => {
            resolve(onSuccess(this.value));
          });
          return;
        }
        if (this.state === 'success') {
          resolve(onSuccess(this.value))
          return;
        }
        if (this.state === 'fail') {
          resolve(onFail(this.value));
          return;
        }
      });
      return newPromise;
    }
  }

  function testPromise() {
    let promise = new MyPromise((resolve, reject) => {
      const random = Math.random() * 10;
      if (random > 0) {
        setTimeout(() => {
          resolve(444);
        }, 1000)
      } else {
        reject(333);
      }
    })
    return promise;
  }
  const temp = testPromise();
  temp.then((data) => {
    console.log('success', data);
    return 'nextdata'
  }, (err) => console.log('fail'))
    .then((data) => {
      console.log('递归', data);
    })

  // 判断左右括号「{ & ( & [」是否匹配
  // a[{(bc)}]def ==> true   [{()}]
  // a{(bc)}]def ==> false
  // a(b}c ==> false

  function isMatch(s) {
    const stack = [];
    const map = {
      ')': '(',
      ']': '[',
      '}': '{'
    }
    for (let item of s) {
      if (Object.values(map).includes(item)) {
        stack.push(item);
        continue;
      }
      if (map[item]) {
        const top = stack.pop();
        if (top !== map[item]) {
          return false;
        }
      }
    }
    return stack.length === 0;
  }

  console.log(isMatch('()'), '______________________kk---');
  console.log(isMatch('a[{(bc)}]def'))
  console.log(isMatch('a{(bc)}]def'))
  console.log(isMatch('a(b}c'))

  // memorized 函数 + LRU 缓存策略
  // LRU: 最近最少使用，维护一个 map
  class LRUCache {
    constructor(limit) {
      this.limit = limit;
      this.map = new Map();
    }

    has(key) {
      return this.map.has(key);
    }

    get(key) {
      if (!this.has(key)) {
        return;
      }
      const value = this.map.get(key);
      this.map.delete(key);
      this.map.set(key, value);
      return value;
    }

    put(key, value) {
      if (this.has(key)) {
        this.map.delete(key);
      }
      if (this.map.size >= this.limit) {
        const oldKey = this.map.keys().next().value;
        console.log('超出limit');
        this.map.delete(oldKey);
      }
      this.map.set(key, value);
    }
  }

  function memoizedFunction(fn, limit) {
    const LRUCacheIns = new LRUCache(limit);

    return function(...args) {
      const key = JSON.stringify(args);
      if (LRUCacheIns.has(key)) {
        return LRUCacheIns.get(key);
      }
      const value = fn.apply(this, args);
      LRUCacheIns.put(key, value);
      return value;
    }
  }

  function add(a, b) {
    return a + b;
  }

  const mFn = memoizedFunction(add, 3);
  console.log(mFn(3, 4), '_mmmmm');
  console.log(mFn(3, 5))
  console.log(mFn(3, 6))
  console.log(mFn(3, 7))
  console.log(mFn(3, 89))

  // 防抖，节流
  function debounce(fn, delay, runFirst) {
    let timeId = null;

    return function (...args) {
      if (timeId) {
        clearTimeout(timeId);
      }
      timeId = setTimeout(() => {
        fn.apply(this, args);
        timeId = null;
      }, delay);
    }
  }

  const debouncedFunction = debounce(() => {
    console.log('执行了防抖函数');
  }, 2000, true);

  // 连续触发，但只有最后一次触发后延时结束才会执行函数
  debouncedFunction();
  debouncedFunction();
  debouncedFunction();
  // 等待 200ms 后输出: 执行了防抖函数

  // 节流：按照固定频率运行，通过时间差来实现
  function throttle(fn, delay) {
    let timeId = null;

    return function(...args) {
      if (timeId) {
        return;
      }
      timeId = setTimeout(() => {
        fn.apply(this, args);
        timeId = null;
      }, delay);
    }
  }
</script>

</html>
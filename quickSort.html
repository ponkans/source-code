<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    // 快排, 二叉树前序遍历思路
    const testArr = [2, 1, 3, 4, 0, 20, 4, 70, -1];

    function quickSort(arr, low, high) {
      if (low > high) {
        return;
      }
      const middle = partition(arr, low, high);
      quickSort(arr, low, middle - 1);
      quickSort(arr, middle + 1, high);
    }

    function partition(arr, low, high) {
      // 找到中间索引，左边的小，右边的大
      let slow = low;
      let middleValue = arr[high];
      for (let fast = slow; fast <= high; fast++) {
        // 这里必须是 <= , 不然如果第一次选择的 middleValue 就是数组中最小的数，那么就会死循环了，因为 slow 不会移动
        if (arr[fast] <= middleValue) {
          swap(arr, slow, fast);
          slow++;
        }
      }
      return slow - 1;
    }

    function swap(arr, i, j) {
      const temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }

    // 示例用法
    quickSort(testArr, 0, testArr.length - 1);
    console.log(testArr);
  </script>
</html>
